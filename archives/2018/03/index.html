<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2018/3 | 猿大白</title>
  
  
  <meta name="description" content="专注于Linux/云计算/网络/CC++/Python/Go等技术栈">
  

  <link rel="alternate" href="/atom.xml" title="猿大白">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  
  <meta name="theme-color" content="#f24e32">
  
  <meta name="msapplication-TileColor" content="#f24e32">
  
  <meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/xaoxuu/assets@18.12.27/favicon/favicons/browserconfig.xml">
  
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">

  
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-fonts@master/Ubuntu/Ubuntu-Regular.ttf">
  
  <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@18.12.27/favicon/favicon.ico" type="image/x-icon">
  
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@18.12.27/favicon/favicons/favicon-32x32.png" type="image/x-icon" sizes="32x32">
  
  <link rel="apple-touch-icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@18.12.27/favicon/favicons/apple-touch-icon.png" type="image/png" sizes="180x180">
  
  <link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@18.12.27/favicon/favicons/safari-pinned-tab.svg" color="#f24e32">
  
  <link rel="manifest" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@18.12.27/favicon/favicons/site.webmanifest">
  
  

  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
    <div id="loading-bar-wrapper">
  <div id="loading-bar" class="material"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header material">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          猿大白
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="home" class="nav flat-box" href="/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="friends" class="nav flat-box" href="/friends/">
									<i class="fas fa-users fa-fw"></i>&nbsp;导航
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="home" class="nav flat-box" href="/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="friends" class="nav flat-box" href="/friends/">
											<i class="fas fa-users fa-fw"></i>&nbsp;导航
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
	
    <script>
        window.subData= { title:'year : 2018.3'}
    </script>


<section class="post-list">
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        <div class="post-wrapper">
          <article class="post reveal ">
    
<section class="meta">
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/03/28/tech/cloud/container/docker/Docker_基础技术之_Linux_cgroups_详解/">
              
                  Docker 基础技术之 Linux cgroups 详解
              
          </a>
      </h2>
    

    
      <time class="metatag time">
        <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;2018-03-28
      </time>
    

    
      
    
    <div class="metatag cats">
        <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;<a class="categories" href="/categories/Docker/">Docker</a>
    </div>


    

    

    

  </div>
</section>

    <section class="article typo">
        <blockquote>
<p>文章首发于我的公众号「Linux云计算网络」，欢迎关注，第一时间掌握技术干货！</p>
</blockquote>
<p>前面两篇文章我们总结了 Docker 背后使用的资源隔离技术 Linux namespace，本篇将讨论另外一个技术——资源限额，这是由 Linux cgroups 来实现的。</p>
<blockquote>
<p>cgroups 是 Linux 内核提供的一种机制，这种机制可以根据需求把一系列任务及子任务整合（或分隔）到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。（来自 《Docker 容器与容器云》）</p>
</blockquote>
<p>通俗来说，cgroups 可以限制和记录任务组（进程组或线程组）使用的物理资源（包括 CPU、内存、IO 等）。</p>
<p>为了方便用户（程序员）操作，cgroups 以一个伪文件系统的方式实现，并对外提供 API，用户对文件系统的操作就是对 cgroups 的操作。</p>
<p>从实现上来，cgroups 实际上是给每个执行任务挂了一个钩子，当任务执行过程中涉及到对资源的分配使用时，就会触发钩子上的函数对相应的资源进行检测，从而对资源进行限制和优先级分配。</p>
<h3 id="cgroups-的作用"><a href="#cgroups-的作用" class="headerlink" title="cgroups 的作用"></a>cgroups 的作用</h3><hr>
<p>总结下来，cgroups 提供以下四个功能：</p>
<p><strong>资源限制：</strong> cgroups 可以对任务使用的资源总额进行限制，如设定应用运行时使用内存的上限，一旦超过这个配额就发出 OOM（Out of Memory）提示。</p>
<p><strong>优先级分配：</strong> 通过分配的 CPU 时间片数量和磁盘 IO 带宽大小，实际上就相当于控制了任务运行的优先级。</p>
<p><strong>资源统计：</strong> cgroups 可以统计系统的资源使用，如 CPU 使用时长、内存用量等，这个功能非常适用于计费。</p>
<p><strong>任务控制：</strong> cgroups 可以对任务执行挂起、恢复等操作。</p>
<h3 id="cgroups-的子系统"><a href="#cgroups-的子系统" class="headerlink" title="cgroups 的子系统"></a>cgroups 的子系统</h3><hr>
<p>cgroups 在设计时根据不同的资源类别分为不同的子系统，一个子系统本质上是一个资源控制器，比如 CPU 资源对应 CPU 子系统，负责控制 CPU 时间片的分配，内存对应内存子系统，负责限制内存的使用量。进一步，一个子系统或多个子系统可以组成一个 cgroup，cgroups 中的资源控制都是以 cgroup 为单位来实现，一个任务（或进程或线程）可以加入某个 cgroup，也可以从一个 cgroup 移动到另一个 cgroup，但这里有一些限制，在此就不再赘述了，详细查阅相关资料了解。</p>
<p>对于我们来说，最关键的是知道怎么用，下面就针对 CPU、内存和 IO 资源来看 Docker 是如何使用的？</p>
<p>对于 CPU，Docker 使用参数 -c 或 –cpu-shares 来设置一个容器使用的 CPU 权重，权重的大小也影响了 CPU 使用的优先级。</p>
<p>如下，启动两个容器，并分配不同的 CPU 权重，最终 CPU 使用率情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name &quot;container_A&quot; -c 1024 ubuntu</span><br><span class="line">docker run --name &quot;container_B&quot; -c 512 ubuntu</span><br></pre></td></tr></table></figure></p>
<center><img src="/images/docker/cgroup_cpu.png" alt=""></center>

<p>当只有一个容器时，即使指定较少的 CPU 权重，它也会占满整个 CPU，说明这个权重只是相对权重，如下将上面的 “container_A” 停止，“container_B” 就分配到全部可用的 CPU。</p>
<center><img src="/images/docker/cgroup_cpu1.png" alt=""></center>

<p>对于内存，Docker 使用 -m（设置内存的限额）和 –memory-swap（设置内存和 swap 的限额）来控制容器内存的使用量，如下，给容器限制 200M 的内存和 100M 的 swap，然后给容器内的一个工作线程分配 280M 的内存，因为 280M 在容许的 300M 范围内，没有问题。其内存分配过程是不断分配又释放，如下：</p>
<center><img src="/images/docker/cgroup_mem.jpg" alt=""></center>

<p>如果让工作线程使用内存超过 300M，则出现内存超限的错误，容器退出，如下：</p>
<center><img src="/images/docker/cgroup_mem1.jpg" alt=""></center>

<p>对于 IO 资源，其使用方式与 CPU 一样，使用 –blkio-weight 来设置其使用权重，IO 衡量的两个指标是 bps（byte per second，每秒读写的数据量） 和 iops（io per second， 每秒 IO 的次数）,实际使用，一般使用这两个指标来衡量 IO 读写的带宽，几种使用参数如下：</p>
<ul>
<li>–device-read-bps，限制读某个设备的 bps。</li>
<li>–device-write-bps，限制写某个设备的 bps。</li>
<li>–device-read-iops，限制读某个设备的 iops。</li>
<li>–device-write-iops，限制写某个设备的 iops。</li>
</ul>
<p>假如限制容器对其文件系统 /dev/sda 的 bps 写速率为 30MB/s，则在容器中用 dd 测试其写磁盘的速率如下，可见小于 30MB/s。</p>
<center><img src="/images/docker/cgroup_dev.png" alt=""></center>

<p>如果是正常情况下，我的机器可以达到 56.7MB/s，一般都是超 1G 的。</p>
<center><img src="/images/docker/cgroup_dev1.png" alt=""></center>

<p>上面几个资源使用限制的例子，本质上都是调用了 Linux kernel 的 cgroups 机制来实现的，每个容器创建后，Linux 会为每个容器创建一个 cgroup 目录，以容器的 ID 命名，目录在 /sys/fs/cgroup/ 中，针对上面的 CPU 资源限制的例子，我们可以在  /sys/fs/cgroup/cpu/docker 中看到相关信息，如下：</p>
<center><img src="/images/docker/cgroup_info.jpg" alt=""></center>

<p>其中，cpu.shares 中保存的就是限制的数值，其他还有很多项，感兴趣可以动手实验看看。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>cgroups 的作用，cgroups 的实现，cgroups 的子系统机制，CPU、内存和 IO 的使用方式，以及对应 Linux 的 cgroups 文件目录。</p>
<p>PS：文章未经我允许，不得转载，否则后果自负。</p>
<center>–END–</center>

<hr>
<blockquote>
<p>欢迎扫👇的二维码关注我的微信公众号，后台回复「m」，可以获取往期所有技术博文推送，更多资料回复下列关键字获取。</p>
</blockquote>
<p><img src="/images/weichat.png" alt=""></p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Linux/"><i class="fas fa-hashtag fa-fw"></i>Linux</a>
                
                    <a href="/tags/云计算/"><i class="fas fa-hashtag fa-fw"></i>云计算</a>
                
                    <a href="/tags/容器/"><i class="fas fa-hashtag fa-fw"></i>容器</a>
                
                    <a href="/tags/Docker/"><i class="fas fa-hashtag fa-fw"></i>Docker</a>
                
                    <a href="/tags/Cgroup/"><i class="fas fa-hashtag fa-fw"></i>Cgroup</a>
                
            </div>
        
    </section>
</article>

        </div>
      
    
      
        <div class="post-wrapper">
          <article class="post reveal ">
    
<section class="meta">
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/03/13/tech/cloud/container/docker/Docker_基础技术之_Linux_namespace_源码分析/">
              
                  Docker 基础技术之 Linux namespace 源码分析
              
          </a>
      </h2>
    

    
      <time class="metatag time">
        <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;2018-03-13
      </time>
    

    
      
    
    <div class="metatag cats">
        <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;<a class="categories" href="/categories/Docker/">Docker</a>
    </div>


    

    

    

  </div>
</section>

    <section class="article typo">
        <blockquote>
<p>文章首发于我的公众号「Linux云计算网络」，欢迎关注，第一时间掌握技术干货！</p>
</blockquote>
<p>上篇我们从进程 clone 的角度，结合代码简单分析了 Linux 提供的 6 种 namespace，本篇从源码上进一步分析 Linux namespace，让你对 Docker namespace 的隔离机制有更深的认识。我用的是 Linux-4.1.19 的版本，由于 namespace 模块更新都比较少，所以，只要 3.0 以上的版本都是差不多的。</p>
<h3 id="从内核进程描述符-task-struct-开始切入"><a href="#从内核进程描述符-task-struct-开始切入" class="headerlink" title="从内核进程描述符 task_struct 开始切入"></a>从内核进程描述符 task_struct 开始切入</h3><hr>
<p>由于 Linux namespace 是用来做进程资源隔离的，所以在进程描述符中，一定有 namespace 所对应的信息，我们可以从这里开始切入代码。</p>
<p>首先找到描述进程信息 task_struct，找到指向 namespace 的结构 struct *nsproxy（sched.h）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">......</span><br><span class="line">/* namespaces */</span><br><span class="line">struct nsproxy *nsproxy;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 nsproxy 结构体定义在 nsproxy.h 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* A structure to contain pointers to all per-process</span><br><span class="line">* namespaces - fs (mount), uts, network, sysvipc, etc.</span><br><span class="line">*</span><br><span class="line">* &apos;count&apos; is the number of tasks holding a reference.</span><br><span class="line">* The count for each namespace, then, will be the number</span><br><span class="line">* of nsproxies pointing to it, not the number of tasks.</span><br><span class="line">*</span><br><span class="line">* The nsproxy is shared by tasks which share all namespaces.</span><br><span class="line">* As soon as a single namespace is cloned or unshared, the</span><br><span class="line">* nsproxy is copied.</span><br><span class="line">*/</span><br><span class="line">struct nsproxy &#123;</span><br><span class="line">    atomic_t count;</span><br><span class="line">    struct uts_namespace *uts_ns;</span><br><span class="line">    struct ipc_namespace *ipc_ns;</span><br><span class="line">    struct mnt_namespace *mnt_ns;</span><br><span class="line">    struct pid_namespace *pid_ns;</span><br><span class="line">    struct net        *net_ns;</span><br><span class="line">&#125;;</span><br><span class="line">extern struct nsproxy init_nsproxy;</span><br></pre></td></tr></table></figure></p>
<p>这个结构是被所有 namespace 所共享的，只要一个 namespace 被 clone 了，nsproxy 也会被 clone。注意到，由于 user namespace 是和其他 namespace 耦合在一起的，所以没出现在上述结构中。</p>
<p>同时，nsproxy.h 中还定义了一些对 namespace 的操作，包括 copy_namespaces 等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int copy_namespaces(unsigned long flags, struct task_struct *tsk);</span><br><span class="line">void exit_task_namespaces(struct task_struct *tsk);</span><br><span class="line">void switch_task_namespaces(struct task_struct *tsk, struct nsproxy *new);</span><br><span class="line">void free_nsproxy(struct nsproxy *ns);</span><br><span class="line">int unshare_nsproxy_namespaces(unsigned long, struct nsproxy **,</span><br><span class="line">struct fs_struct *);</span><br></pre></td></tr></table></figure></p>
<p>task_struct，nsproxy，几种 namespace 之间的关系如下所示：</p>
<center><img src="/images/docker/ns_rela.jpg" alt=""></center>

<h3 id="各个-namespace-的初始化"><a href="#各个-namespace-的初始化" class="headerlink" title="各个 namespace 的初始化"></a>各个 namespace 的初始化</h3><hr>
<p>在各个 namespace 结构定义下都有个 init 函数，nsproxy 也有个 init_nsproxy 函数，init_nsproxy 在  task 初始化的时候会被初始化，附带的，init_nsproxy 中定义了各个 namespace 的 init 函数，如下：<br>在 init_task 函数中（init_task.h）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*  INIT_TASK is used to set up the first task table, touch at</span><br><span class="line">* your own risk!. Base=0, limit=0x1fffff (=2MB)</span><br><span class="line">*/</span><br><span class="line">#define INIT_TASK(tsk)  \</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">.nsproxy  = &amp;init_nsproxy,        </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续跟进 init_nsproxy，在 nsproxy.c 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct nsproxy init_nsproxy = &#123;</span><br><span class="line">.count      = ATOMIC_INIT(1),</span><br><span class="line">.uts_ns      = &amp;init_uts_ns,</span><br><span class="line">#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)</span><br><span class="line">.ipc_ns      = &amp;init_ipc_ns,</span><br><span class="line">#endif</span><br><span class="line">.mnt_ns      = NULL,</span><br><span class="line">.pid_ns_for_children  = &amp;init_pid_ns,</span><br><span class="line">#ifdef CONFIG_NET</span><br><span class="line">.net_ns      = &amp;init_net,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可见，init_nsproxy 中，对 uts, ipc, pid, net 都进行了初始化，但 mount 却没有。</p>
<h3 id="创建新的-namespace"><a href="#创建新的-namespace" class="headerlink" title="创建新的 namespace"></a>创建新的 namespace</h3><hr>
<p>初始化完之后，下面看看如何创建一个新的 namespace，通过前面的文章，我们知道是通过 clone 函数来完成的，在 Linux kernel 中，fork/vfork() 对 clone 进行了封装，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __ARCH_WANT_SYS_FORK</span><br><span class="line">SYSCALL_DEFINE0(fork)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_MMU</span><br><span class="line">    return do_fork(SIGCHLD, 0, 0, NULL, NULL);</span><br><span class="line">#else</span><br><span class="line">    /* can not support in nommu mode */</span><br><span class="line">    return -EINVAL;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef __ARCH_WANT_SYS_VFORK</span><br><span class="line">SYSCALL_DEFINE0(vfork)</span><br><span class="line">&#123;</span><br><span class="line">    return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0, 0, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef __ARCH_WANT_SYS_CLONE</span><br><span class="line">#ifdef CONFIG_CLONE_BACKWARDS</span><br><span class="line">SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,</span><br><span class="line">    int __user *, parent_tidptr,</span><br><span class="line">    int, tls_val,</span><br><span class="line">    int __user *, child_tidptr)</span><br><span class="line">#elif defined(CONFIG_CLONE_BACKWARDS2)</span><br><span class="line">SYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,</span><br><span class="line">    int __user *, parent_tidptr,</span><br><span class="line">    int __user *, child_tidptr,</span><br><span class="line">    int, tls_val)</span><br><span class="line">#elif defined(CONFIG_CLONE_BACKWARDS3)</span><br><span class="line">SYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,</span><br><span class="line">    int, stack_size,</span><br><span class="line">    int __user *, parent_tidptr,</span><br><span class="line">    int __user *, child_tidptr,</span><br><span class="line">    int, tls_val)</span><br><span class="line">#else</span><br><span class="line">SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,</span><br><span class="line">    int __user *, parent_tidptr,</span><br><span class="line">    int __user *, child_tidptr,</span><br><span class="line">    int, tls_val)</span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">    return do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>可以看到，无论是 fork() 还是 vfork()，最终都会调用到 do_fork() 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*  Ok, this is the main fork-routine.</span><br><span class="line">*</span><br><span class="line">* It copies the process, and if successful kick-starts</span><br><span class="line">* it and waits for it to finish using the VM if required.</span><br><span class="line">*/</span><br><span class="line">long do_fork(unsigned long clone_flags,</span><br><span class="line">unsigned long stack_start,</span><br><span class="line">unsigned long stack_size,</span><br><span class="line">int __user *parent_tidptr,</span><br><span class="line">int __user *child_tidptr)</span><br><span class="line">&#123;</span><br><span class="line">// 创建进程描述符指针</span><br><span class="line">    struct task_struct *p;</span><br><span class="line">    int trace = 0;</span><br><span class="line">    long nr;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Determine whether and which event to report to ptracer.  When</span><br><span class="line">* called from kernel_thread or CLONE_UNTRACED is explicitly</span><br><span class="line">* requested, no event is reported; otherwise, report if the event</span><br><span class="line">* for the type of forking is enabled.</span><br><span class="line">*/</span><br><span class="line">if (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">    if (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">        trace = PTRACE_EVENT_VFORK;</span><br><span class="line">    else if ((clone_flags &amp; CSIGNAL) != SIGCHLD)</span><br><span class="line">        trace = PTRACE_EVENT_CLONE;</span><br><span class="line">    else</span><br><span class="line">        trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">    if (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">        trace = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 复制进程描述符，返回值是 task_struct</span><br><span class="line">p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">child_tidptr, NULL, trace);</span><br><span class="line">/*</span><br><span class="line">* Do this prior waking up the new thread - the thread pointer</span><br><span class="line">* might get invalid after that point, if the thread exits quickly.</span><br><span class="line">*/</span><br><span class="line">if (!IS_ERR(p)) &#123;</span><br><span class="line">    struct completion vfork;</span><br><span class="line">    struct pid *pid;</span><br><span class="line"></span><br><span class="line">    trace_sched_process_fork(current, p);</span><br><span class="line"></span><br><span class="line">    // 得到新进程描述符的 pid</span><br><span class="line">    pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">    nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">    if (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">    put_user(nr, parent_tidptr);</span><br><span class="line"></span><br><span class="line">    // 调用 vfork() 方法，完成相关的初始化工作  </span><br><span class="line">    if (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">    p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">    init_completion(&amp;vfork);</span><br><span class="line">    get_task_struct(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将新进程加入到调度器中，为其分配 CPU，准备执行</span><br><span class="line">    wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">    // fork() 完成，子进程开始运行，并让 ptrace 跟踪</span><br><span class="line">    /* forking complete and child started to run, tell ptracer */</span><br><span class="line">    if (unlikely(trace))</span><br><span class="line">    ptrace_event_pid(trace, pid);</span><br><span class="line"></span><br><span class="line">    // 如果是 vfork()，将父进程加入等待队列，等待子进程完成</span><br><span class="line">    if (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">    if (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">    ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    put_pid(pid);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    nr = PTR_ERR(p);</span><br><span class="line">&#125;</span><br><span class="line">    return nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do_fork() 首先调用 copy_process 将父进程信息复制给子进程，然后调用 vfork() 完成相关的初始化工作，接着调用 wake_up_new_task() 将进程加入调度器中，为之分配 CPU。最后，等待子进程退出。</p>
<p>copy_process():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">static struct task_struct *copy_process(unsigned long clone_flags,</span><br><span class="line">    unsigned long stack_start,</span><br><span class="line">    unsigned long stack_size,</span><br><span class="line">    int __user *child_tidptr,</span><br><span class="line">    struct pid *pid,</span><br><span class="line">    int trace)</span><br><span class="line">&#123;</span><br><span class="line">int retval;</span><br><span class="line">// 创建进程描述符指针</span><br><span class="line">struct task_struct *p;</span><br><span class="line"></span><br><span class="line">// 检查 clone flags 的合法性，比如 CLONE_NEWNS 与 CLONE_FS 是互斥的</span><br><span class="line">if ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">if ((clone_flags &amp; (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Thread groups must share signals as well, and detached threads</span><br><span class="line">* can only be started up within the thread group.</span><br><span class="line">*/</span><br><span class="line">if ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Shared signal handlers imply shared VM. By way of the above,</span><br><span class="line">* thread groups also imply shared VM. Blocking this case allows</span><br><span class="line">* for various simplifications in other code.</span><br><span class="line">*/</span><br><span class="line">if ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Siblings of global init remain as zombies on exit since they are</span><br><span class="line">* not reaped by their parent (swapper). To solve this and to avoid</span><br><span class="line">* multi-rooted process trees, prevent global and container-inits</span><br><span class="line">* from creating siblings.</span><br><span class="line">*/</span><br><span class="line">// 比如CLONE_PARENT时得检查当前signal flags是否为SIGNAL_UNKILLABLE，防止kill init进程。</span><br><span class="line">if ((clone_flags &amp; CLONE_PARENT) &amp;&amp;</span><br><span class="line">current-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE)</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* If the new process will be in a different pid or user namespace</span><br><span class="line">* do not allow it to share a thread group or signal handlers or</span><br><span class="line">* parent with the forking task.</span><br><span class="line">*/</span><br><span class="line">if (clone_flags &amp; CLONE_SIGHAND) &#123;</span><br><span class="line">if ((clone_flags &amp; (CLONE_NEWUSER | CLONE_NEWPID)) ||</span><br><span class="line">(task_active_pid_ns(current) !=</span><br><span class="line">current-&gt;nsproxy-&gt;pid_ns_for_children))</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retval = security_task_create(clone_flags);</span><br><span class="line">if (retval)</span><br><span class="line">goto fork_out;</span><br><span class="line"></span><br><span class="line">retval = -ENOMEM;</span><br><span class="line">// 复制当前的 task_struct</span><br><span class="line">p = dup_task_struct(current);</span><br><span class="line">if (!p)</span><br><span class="line">goto fork_out;</span><br><span class="line"></span><br><span class="line">ftrace_graph_init_task(p);</span><br><span class="line"></span><br><span class="line">rt_mutex_init_task(p);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PROVE_LOCKING</span><br><span class="line">DEBUG_LOCKS_WARN_ON(!p-&gt;hardirqs_enabled);</span><br><span class="line">DEBUG_LOCKS_WARN_ON(!p-&gt;softirqs_enabled);</span><br><span class="line">#endif</span><br><span class="line">retval = -EAGAIN;</span><br><span class="line"></span><br><span class="line">// 检查进程是否超过限制，由 OS 定义</span><br><span class="line">if (atomic_read(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;=</span><br><span class="line">task_rlimit(p, RLIMIT_NPROC)) &#123;</span><br><span class="line">if (p-&gt;real_cred-&gt;user != INIT_USER &amp;&amp;</span><br><span class="line">!capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">goto bad_fork_free;</span><br><span class="line">&#125;</span><br><span class="line">current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;</span><br><span class="line"></span><br><span class="line">retval = copy_creds(p, clone_flags);</span><br><span class="line">if (retval &lt; 0)</span><br><span class="line">goto bad_fork_free;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* If multiple threads are within copy_process(), then this check</span><br><span class="line">* triggers too late. This doesn&apos;t hurt, the check is only there</span><br><span class="line">* to stop root fork bombs.</span><br><span class="line">*/</span><br><span class="line">retval = -EAGAIN;</span><br><span class="line">// 检查进程数是否超过 max_threads，由内存大小定义</span><br><span class="line">if (nr_threads &gt;= max_threads)</span><br><span class="line">goto bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">// ......</span><br><span class="line"></span><br><span class="line">// 初始化 io 计数器</span><br><span class="line">task_io_accounting_init(&amp;p-&gt;ioac);</span><br><span class="line">acct_clear_integrals(p);</span><br><span class="line"></span><br><span class="line">// 初始化 CPU 定时器</span><br><span class="line">posix_cpu_timers_init(p);</span><br><span class="line"></span><br><span class="line">// ......</span><br><span class="line"></span><br><span class="line">// 初始化进程数据结构，并为进程分配 CPU，进程状态设置为 TASK_RUNNING</span><br><span class="line">/* Perform scheduler related setup. Assign this task to a CPU. */</span><br><span class="line">retval = sched_fork(clone_flags, p);</span><br><span class="line"></span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_policy;</span><br><span class="line"></span><br><span class="line">retval = perf_event_init_task(p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_policy;</span><br><span class="line">retval = audit_alloc(p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_perf;</span><br><span class="line">/* copy all the process information */</span><br><span class="line">// 复制所有进程信息，包括文件系统，信号处理函数、信号、内存管理等</span><br><span class="line">shm_init_task(p);</span><br><span class="line">retval = copy_semundo(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_audit;</span><br><span class="line">retval = copy_files(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_semundo;</span><br><span class="line">retval = copy_fs(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_files;</span><br><span class="line">retval = copy_sighand(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_fs;</span><br><span class="line">retval = copy_signal(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_sighand;</span><br><span class="line">retval = copy_mm(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_signal;</span><br><span class="line">// !!! 复制 namespace</span><br><span class="line">retval = copy_namespaces(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_mm;</span><br><span class="line">retval = copy_io(clone_flags, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_namespaces;</span><br><span class="line">// 初始化子进程内核栈</span><br><span class="line">retval = copy_thread(clone_flags, stack_start, stack_size, p);</span><br><span class="line">if (retval)</span><br><span class="line">goto bad_fork_cleanup_io;</span><br><span class="line">// 为新进程分配新的 pid</span><br><span class="line">if (pid != &amp;init_struct_pid) &#123;</span><br><span class="line">pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children);</span><br><span class="line">if (IS_ERR(pid)) &#123;</span><br><span class="line">retval = PTR_ERR(pid);</span><br><span class="line">goto bad_fork_cleanup_io;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ......</span><br><span class="line"></span><br><span class="line">// 返回新进程 p</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>copy_process 主要分为三步：首先调用 dup_task_struct() 复制当前的进程描述符信息 task_struct，为新进程分配新的堆栈，第二步调用 sched_fork() 初始化进程数据结构，为其分配 CPU，把进程状态设置为 TASK_RUNNING，最后一步就是调用 copy_namespaces() 复制 namesapces。我们重点关注最后一步 copy_namespaces()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* called from clone.  This now handles copy for nsproxy and all</span><br><span class="line">* namespaces therein.</span><br><span class="line">*/</span><br><span class="line">int copy_namespaces(unsigned long flags, struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">struct nsproxy *old_ns = tsk-&gt;nsproxy;</span><br><span class="line">struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);</span><br><span class="line">struct nsproxy *new_ns;</span><br><span class="line"></span><br><span class="line">if (likely(!(flags &amp; (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |</span><br><span class="line">CLONE_NEWPID | CLONE_NEWNET)))) &#123;</span><br><span class="line">get_nsproxy(old_ns);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!ns_capable(user_ns, CAP_SYS_ADMIN))</span><br><span class="line">return -EPERM;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* CLONE_NEWIPC must detach from the undolist: after switching</span><br><span class="line">* to a new ipc namespace, the semaphore arrays from the old</span><br><span class="line">* namespace are unreachable.  In clone parlance, CLONE_SYSVSEM</span><br><span class="line">* means share undolist with parent, so we must forbid using</span><br><span class="line">* it along with CLONE_NEWIPC.</span><br><span class="line">*/</span><br><span class="line">if ((flags &amp; (CLONE_NEWIPC | CLONE_SYSVSEM)) ==</span><br><span class="line">(CLONE_NEWIPC | CLONE_SYSVSEM)) </span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-&gt;fs);</span><br><span class="line">if (IS_ERR(new_ns))</span><br><span class="line">return  PTR_ERR(new_ns);</span><br><span class="line"></span><br><span class="line">tsk-&gt;nsproxy = new_ns;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，copy_namespace() 主要基于“旧的” namespace 创建“新的” namespace，核心函数在于 create_new_namespaces：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Create new nsproxy and all of its the associated namespaces.</span><br><span class="line">* Return the newly created nsproxy.  Do not attach this to the task,</span><br><span class="line">* leave it to the caller to do proper locking and attach it to task.</span><br><span class="line">*/</span><br><span class="line">static struct nsproxy *create_new_namespaces(unsigned long flags,</span><br><span class="line">struct task_struct *tsk, struct user_namespace *user_ns,</span><br><span class="line">struct fs_struct *new_fs)</span><br><span class="line">&#123;</span><br><span class="line">struct nsproxy *new_nsp;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">// 创建新的 nsproxy</span><br><span class="line">new_nsp = create_nsproxy();</span><br><span class="line">if (!new_nsp)</span><br><span class="line">return ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">//创建 mnt namespace</span><br><span class="line">new_nsp-&gt;mnt_ns = copy_mnt_ns(flags, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs);</span><br><span class="line">if (IS_ERR(new_nsp-&gt;mnt_ns)) &#123;</span><br><span class="line">err = PTR_ERR(new_nsp-&gt;mnt_ns);</span><br><span class="line">goto out_ns;</span><br><span class="line">&#125;</span><br><span class="line">//创建 uts namespace</span><br><span class="line">new_nsp-&gt;uts_ns = copy_utsname(flags, user_ns, tsk-&gt;nsproxy-&gt;uts_ns);</span><br><span class="line">if (IS_ERR(new_nsp-&gt;uts_ns)) &#123;</span><br><span class="line">err = PTR_ERR(new_nsp-&gt;uts_ns);</span><br><span class="line">goto out_uts;</span><br><span class="line">&#125;</span><br><span class="line">//创建 ipc namespace</span><br><span class="line">new_nsp-&gt;ipc_ns = copy_ipcs(flags, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns);</span><br><span class="line">if (IS_ERR(new_nsp-&gt;ipc_ns)) &#123;</span><br><span class="line">err = PTR_ERR(new_nsp-&gt;ipc_ns);</span><br><span class="line">goto out_ipc;</span><br><span class="line">&#125;</span><br><span class="line">//创建 pid namespace</span><br><span class="line">new_nsp-&gt;pid_ns_for_children =</span><br><span class="line">copy_pid_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;pid_ns_for_children);</span><br><span class="line">if (IS_ERR(new_nsp-&gt;pid_ns_for_children)) &#123;</span><br><span class="line">err = PTR_ERR(new_nsp-&gt;pid_ns_for_children);</span><br><span class="line">goto out_pid;</span><br><span class="line">&#125;</span><br><span class="line">//创建 network namespace</span><br><span class="line">new_nsp-&gt;net_ns = copy_net_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;net_ns);</span><br><span class="line">if (IS_ERR(new_nsp-&gt;net_ns)) &#123;</span><br><span class="line">err = PTR_ERR(new_nsp-&gt;net_ns);</span><br><span class="line">goto out_net;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return new_nsp;</span><br><span class="line">// 出错处理</span><br><span class="line">out_net:</span><br><span class="line">if (new_nsp-&gt;pid_ns_for_children)</span><br><span class="line">put_pid_ns(new_nsp-&gt;pid_ns_for_children);</span><br><span class="line">out_pid:</span><br><span class="line">if (new_nsp-&gt;ipc_ns)</span><br><span class="line">put_ipc_ns(new_nsp-&gt;ipc_ns);</span><br><span class="line">out_ipc:</span><br><span class="line">if (new_nsp-&gt;uts_ns)</span><br><span class="line">put_uts_ns(new_nsp-&gt;uts_ns);</span><br><span class="line">out_uts:</span><br><span class="line">if (new_nsp-&gt;mnt_ns)</span><br><span class="line">put_mnt_ns(new_nsp-&gt;mnt_ns);</span><br><span class="line">out_ns:</span><br><span class="line">kmem_cache_free(nsproxy_cachep, new_nsp);</span><br><span class="line">return ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在create_new_namespaces()中，分别调用 create_nsproxy(), create_utsname(), create_ipcs(), create_pid_ns(), create_net_ns(), create_mnt_ns() 来创建 nsproxy 结构，uts，ipcs，pid，mnt，net。</p>
<p>具体的函数我们就不再分析，基本到此为止，我们从子进程创建，到子进程相关的信息的初始化，包括文件系统，CPU，内存管理等，再到各个 namespace 的创建，都走了一遍，下面附上 namespace 创建的代码流程图。</p>
<center><img src="/images/docker/ns_call.jpg" alt=""></center>


<p>mnt namespace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">mnt namespace:</span><br><span class="line">struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,</span><br><span class="line">struct user_namespace *user_ns, struct fs_struct *new_fs)</span><br><span class="line">&#123;</span><br><span class="line">struct mnt_namespace *new_ns;</span><br><span class="line">struct vfsmount *rootmnt = NULL, *pwdmnt = NULL;</span><br><span class="line">struct mount *p, *q;</span><br><span class="line">struct mount *old;</span><br><span class="line">struct mount *new;</span><br><span class="line">int copy_flags;</span><br><span class="line"></span><br><span class="line">BUG_ON(!ns);</span><br><span class="line"></span><br><span class="line">if (likely(!(flags &amp; CLONE_NEWNS))) &#123;</span><br><span class="line">get_mnt_ns(ns);</span><br><span class="line">return ns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">old = ns-&gt;root;</span><br><span class="line">// 分配新的 mnt namespace</span><br><span class="line">new_ns = alloc_mnt_ns(user_ns);</span><br><span class="line">if (IS_ERR(new_ns))</span><br><span class="line">return new_ns;</span><br><span class="line"></span><br><span class="line">namespace_lock();</span><br><span class="line">/* First pass: copy the tree topology */</span><br><span class="line">// 首先 copy root 路径</span><br><span class="line">copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;</span><br><span class="line">if (user_ns != ns-&gt;user_ns)</span><br><span class="line">copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;</span><br><span class="line">new = copy_tree(old, old-&gt;mnt.mnt_root, copy_flags);</span><br><span class="line">if (IS_ERR(new)) &#123;</span><br><span class="line">namespace_unlock();</span><br><span class="line">free_mnt_ns(new_ns);</span><br><span class="line">return ERR_CAST(new);</span><br><span class="line">&#125;</span><br><span class="line">new_ns-&gt;root = new;</span><br><span class="line">list_add_tail(&amp;new_ns-&gt;list, &amp;new-&gt;mnt_list);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Second pass: switch the tsk-&gt;fs-&gt;* elements and mark new vfsmounts</span><br><span class="line">* as belonging to new namespace.  We have already acquired a private</span><br><span class="line">* fs_struct, so tsk-&gt;fs-&gt;lock is not needed.</span><br><span class="line">*/</span><br><span class="line">// 为新进程设置 fs 信息</span><br><span class="line">p = old;</span><br><span class="line">q = new;</span><br><span class="line">while (p) &#123;</span><br><span class="line">q-&gt;mnt_ns = new_ns;</span><br><span class="line">if (new_fs) &#123;</span><br><span class="line">if (&amp;p-&gt;mnt == new_fs-&gt;root.mnt) &#123;</span><br><span class="line">new_fs-&gt;root.mnt = mntget(&amp;q-&gt;mnt);</span><br><span class="line">rootmnt = &amp;p-&gt;mnt;</span><br><span class="line">&#125;</span><br><span class="line">if (&amp;p-&gt;mnt == new_fs-&gt;pwd.mnt) &#123;</span><br><span class="line">new_fs-&gt;pwd.mnt = mntget(&amp;q-&gt;mnt);</span><br><span class="line">pwdmnt = &amp;p-&gt;mnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p = next_mnt(p, old);</span><br><span class="line">q = next_mnt(q, new);</span><br><span class="line">if (!q)</span><br><span class="line">break;</span><br><span class="line">while (p-&gt;mnt.mnt_root != q-&gt;mnt.mnt_root)</span><br><span class="line">p = next_mnt(p, old);</span><br><span class="line">&#125;</span><br><span class="line">namespace_unlock();</span><br><span class="line"></span><br><span class="line">if (rootmnt)</span><br><span class="line">mntput(rootmnt);</span><br><span class="line">if (pwdmnt)</span><br><span class="line">mntput(pwdmnt);</span><br><span class="line"></span><br><span class="line">return new_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，mount namespace 在新建时会新建一个新的 namespace，然后将父进程的 namespace 拷贝过来，并将 mount-&gt;mnt_ns 指向新的 namespace。接着设置进程的 root 路径以及当前路径到新的 namespace，然后为新进程设置新的 vfs 等。从这里就可以看出，在子进程中进行 mount 操作不会影响到父进程中的 mount 信息。</p>
<p>uts namespace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline struct uts_namespace *copy_utsname(unsigned long flags,</span><br><span class="line">struct user_namespace *user_ns, struct uts_namespace *old_ns)</span><br><span class="line">&#123;</span><br><span class="line">if (flags &amp; CLONE_NEWUTS)</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">return old_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uts namespace 直接返回父进程 namespace 信息。</p>
<p>ipc namespace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ipc_namespace *copy_ipcs(unsigned long flags,</span><br><span class="line">struct user_namespace *user_ns, struct ipc_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">if (!(flags &amp; CLONE_NEWIPC))</span><br><span class="line">return get_ipc_ns(ns);</span><br><span class="line">return create_ipc_ns(user_ns, ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ipc namespace 如果是设置了参数 CLONE_NEWIPC，则直接返回父进程的 namespace，否则返回新创建的 namespace。</p>
<p>pid namespace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline struct pid_namespace *copy_pid_ns(unsigned long flags,</span><br><span class="line">struct user_namespace *user_ns, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">if (flags &amp; CLONE_NEWPID)</span><br><span class="line">ns = ERR_PTR(-EINVAL);</span><br><span class="line">return ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pid namespace 直接返回父进程的 namespace。</p>
<p>net namespace</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline struct net *copy_net_ns(unsigned long flags,</span><br><span class="line">struct user_namespace *user_ns, struct net *old_net)</span><br><span class="line">&#123;</span><br><span class="line">if (flags &amp; CLONE_NEWNET)</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">return old_net;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>net namespace 也是直接返回父进程的 namespace。</p>
<p>OK，不知不觉写了这么多，但回头去看，这更像是代码走读，分析深度不够，更详细的大家可以参照源码，源码结构还是比较清晰的。</p>
<p>PS：文章未经我允许，不得转载，否则后果自负。</p>
<center>–END–</center>

<hr>
<blockquote>
<p>欢迎扫👇的二维码关注我的微信公众号，后台回复「m」，可以获取往期所有技术博文推送，更多资料回复下列关键字获取。</p>
</blockquote>
<p><img src="/images/weichat.png" alt=""></p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Linux/"><i class="fas fa-hashtag fa-fw"></i>Linux</a>
                
                    <a href="/tags/云计算/"><i class="fas fa-hashtag fa-fw"></i>云计算</a>
                
                    <a href="/tags/容器/"><i class="fas fa-hashtag fa-fw"></i>容器</a>
                
                    <a href="/tags/Docker/"><i class="fas fa-hashtag fa-fw"></i>Docker</a>
                
                    <a href="/tags/Namespace/"><i class="fas fa-hashtag fa-fw"></i>Namespace</a>
                
            </div>
        
    </section>
</article>

        </div>
      
    
      
        <div class="post-wrapper">
          <article class="post reveal ">
    
<section class="meta">
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/03/08/tech/cloud/container/docker/Docker_基础技术之_Linux_namespace_详解/">
              
                  Docker 基础技术之 Linux namespace 详解
              
          </a>
      </h2>
    

    
      <time class="metatag time">
        <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;2018-03-08
      </time>
    

    
      
    
    <div class="metatag cats">
        <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;<a class="categories" href="/categories/Docker/">Docker</a>
    </div>


    

    

    

  </div>
</section>

    <section class="article typo">
        <blockquote>
<p>文章首发于我的公众号「Linux云计算网络」，欢迎关注，第一时间掌握技术干货！</p>
</blockquote>
<p>Docker 是“新瓶装旧酒”的产物，依赖于 Linux 内核技术 chroot 、namespace 和 cgroup。本篇先来看 namespace 技术。</p>
<p>Docker 和虚拟机技术一样，从操作系统级上实现了资源的隔离，它本质上是宿主机上的进程（容器进程），所以资源隔离主要就是指进程资源的隔离。实现资源隔离的核心技术就是 Linux namespace。这技术和很多语言的命名空间的设计思想是一致的（如 C++ 的 namespace）。</p>
<p>隔离意味着可以抽象出多个轻量级的内核（容器进程），这些进程可以充分利用宿主机的资源，宿主机有的资源容器进程都可以享有，但彼此之间是隔离的，同样，不同容器进程之间使用资源也是隔离的，这样，彼此之间进行相同的操作，都不会互相干扰，安全性得到保障。</p>
<p>为了支持这些特性，Linux namespace 实现了 6 项资源隔离，基本上涵盖了一个小型操作系统的运行要素，包括主机名、用户权限、文件系统、网络、进程号、进程间通信。</p>
<center><img src="/images/docker/docker_ns.png" alt=""></center>

<p>这 6 项资源隔离分别对应 6 种系统调用，通过传入上表中的参数，调用 clone() 函数来完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure></p>
<p>clone() 函数相信大家都不陌生了，它是 fork() 函数更通用的实现方式，通过调用 clone()，并传入需要隔离资源对应的参数，就可以建立一个容器了（隔离什么我们自己控制）。</p>
<p>一个容器进程也可以再 clone() 出一个容器进程，这是容器的嵌套。</p>
<center><img src="/images/docker/docker_clone.jpg" alt=""></center>

<p>如果想要查看当前进程下有哪些 namespace 隔离，可以查看文件 /proc/[pid]/ns （注：该方法仅限于 3.8 版本以后的内核）。</p>
<center><img src="/images/docker/docker_shell.jpg" alt=""></center>

<p>可以看到，每一项 namespace 都附带一个编号，这是唯一标识 namespace 的，如果两个进程指向的 namespace 编号相同，则表示它们同在该 namespace 下。同时也注意到，多了一个 cgroup，这个 namespace 是 4.6 版本的内核才支持的。Docker 目前对它的支持普及度还不高。所以我们暂时先不考虑它。</p>
<p>下面通过简单的代码来实现 6 种 namespace 的隔离效果，让大家有个直观的印象。</p>
<h3 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h3><hr>
<p>UTS namespace 提供了主机名和域名的隔离，这样每个容器就拥有独立的主机名和域名了，在网络上就可以被视为一个独立的节点，在容器中对 hostname 的命名不会对宿主机造成任何影响。</p>
<p>首先，先看总体的代码骨架：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 容器进程运行的程序主函数</span><br><span class="line">int container_main(void *args)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;在容器进程中！\n&quot;);</span><br><span class="line">    execv(container_args[0], container_args); // 执行/bin/bash   return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int args, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;程序开始\n&quot;);</span><br><span class="line">    // clone 容器进程</span><br><span class="line">    int container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD, NULL);</span><br><span class="line">    // 等待容器进程结束</span><br><span class="line">    waitpid(container_pid, NULL, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序骨架调用 clone() 函数实现了子进程的创建工作，并定义子进程的执行函数，clone() 第二个参数指定了子进程运行的栈空间大小，第三个参数即为创建不同 namespace 隔离的关键。</p>
<p>对于 UTS namespace，传入 CLONE_NEWUTS，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS, NULL);</span><br></pre></td></tr></table></figure></p>
<p>为了能够看出容器内和容器外主机名的变化，我们子进程执行函数中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sethostname(&quot;container&quot;, 9);</span><br></pre></td></tr></table></figure></p>
<p>最终运行可以看到效果如下：</p>
<center><img src="/images/docker/docker_show.png" alt=""></center>

<h3 id="IPC-namespace"><a href="#IPC-namespace" class="headerlink" title="IPC namespace"></a>IPC namespace</h3><hr>
<p>IPC namespace 实现了进程间通信的隔离，包括常见的几种进程间通信机制，如信号量，消息队列和共享内存。我们知道，要完成 IPC，需要申请一个全局唯一的标识符，即 IPC 标识符，所以 IPC 资源隔离主要完成的就是隔离 IPC 标识符。</p>
<p>同样，代码修改仅需要加入参数 CLONE_NEWIPC 即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, NULL);</span><br></pre></td></tr></table></figure></p>
<p>为了看出变化，首先在宿主机上建立一个消息队列：</p>
<center><img src="/images/docker/ns_ipc.png" alt=""></center>

<p>然后运行程序，进入容器查看 IPC，没有找到原先建立的 IPC 标识，达到了 IPC 隔离。</p>
<center><img src="/images/docker/ns_ipc1.png" alt=""></center>

<h3 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h3><hr>
<p>PID namespace 完成的是进程号的隔离，同样在 clone() 中加入 CLONE_NEWPID 参数，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID, NULL);</span><br></pre></td></tr></table></figure></p>
<p>效果如下，echo $$ 输出 shell 的 PID 号，发生了变化。</p>
<center><img src="/images/docker/ns_pid.png" alt=""></center>

<p>但是对于 ps/top 之类命令却没有改变：</p>
<center><img src="/images/docker/ns_pid1.jpg" alt=""></center>

<p>原因是 ps/top 之类的命令底层调用的是文件系统的 /proc 文件内容，由于 /proc 文件系统（procfs）还没有挂载到一个与原 /proc 不同的位置，自然在容器中显示的就是宿主机的进程。</p>
<p>我们可以通过在容器中重新挂载 /proc 即可实现隔离，如下：</p>
<center><img src="/images/docker/ns_proc.png" alt=""></center>

<p>这种方式会破坏 root namespace 中的文件系统，当退出容器时，如果 ps 会出现错误，只有再重新挂载一次 /proc 才能恢复。</p>
<center><img src="/images/docker/ns_proc1.jpg" alt=""></center>

<p>一劳永逸地解决这个问题最好的方法就是用接下来介绍的 mount namespace。</p>
<h3 id="mount-namespace"><a href="#mount-namespace" class="headerlink" title="mount namespace"></a>mount namespace</h3><hr>
<p>mount namespace 通过隔离文件系统的挂载点来达到对文件系统的隔离。我们依然在代码中加入 CLONE_NEWNS 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS, NULL);</span><br></pre></td></tr></table></figure></p>
<p>我验证的效果，当退出容器时，还是会有 mount 错误，这没道理，经多方查阅，没有找到问题的根源（有谁知道，可以留言指出）。</p>
<center><img src="/images/docker/ns_mount.jpg" alt=""></center>

<h3 id="Network-namespace"><a href="#Network-namespace" class="headerlink" title="Network namespace"></a>Network namespace</h3><hr>
<p>Network namespace 实现了网络资源的隔离，包括网络设备、IPv4 和 IPv6 协议栈，IP 路由表，防火墙，/proc/net 目录，/sys/class/net 目录，套接字等。</p>
<p>Network namespace 不同于其他 namespace 可以独立工作，要使得容器进程和宿主机或其他容器进程之间通信，需要某种“桥梁机制”来连接彼此（并没有真正的隔离），这是通过创建 veth pair （虚拟网络设备对，有两端，类似于管道，数据从一端传入能从另一端收到，反之亦然）来实现的。当建立 Network namespace 后，内核会首先建立一个 docker0 网桥，功能类似于 Bridge，用于建立各容器之间和宿主机之间的通信，具体就是分别将 veth pair 的两端分别绑定到 docker0 和新建的 namespace 中。</p>
<center><img src="/images/docker/docker_net.jpg" alt=""></center>

<p>和其他 namespace 一样，Network namespace 的创建也是加入 CLONE_NEWNET 参数即可。我们可以简单验证下 IP 地址的情况，如下，IP 被隔离了。</p>
<center><img src="/images/docker/ns_net.jpg" alt=""></center>

<h3 id="User-namespace"><a href="#User-namespace" class="headerlink" title="User namespace"></a>User namespace</h3><hr>
<p>User namespace 主要隔离了安全相关的标识符和属性，包括用户 ID、用户组 ID、root 目录、key 以及特殊权限。简单说，就是一个普通用户的进程通过 clone() 之后在新的 user namespace 中可以拥有不同的用户和用户组，比如可能是超级用户。</p>
<p>同样，可以加入 CLONE_NEWUSER 参数来创建一个 User namespace。然后再子进程执行函数中加入 getuid() 和 getpid() 得到 namespace 内部的 User ID，效果如下：</p>
<center><img src="/images/docker/ns_user.png" alt=""></center>

<p>可以看到，容器内部看到的 UID 和 GID 和外部不同了，默认显示为 65534。这是因为容器找不到其真正的 UID ，所以设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。另外就是用户变为了 nobody，不再是 root，达到了隔离。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>以上就是对 6 种 namespace 从代码上简单直观地演示其实现，当然，真正的实现比这个要复杂得多，然后这 6 种 namespace 实际上也没有完全隔离 Linux 的资源，比如 SElinux、cgroup 以及 /sys 等目录下的资源没有隔离。目前，Docker 在很多方面已经做的很好，但相比虚拟机，仍然有许多安全性问题急需解决。</p>
<p>PS：文章未经我允许，不得转载，否则后果自负。</p>
<center>–END–</center>

<hr>
<blockquote>
<p>欢迎扫👇的二维码关注我的微信公众号，后台回复「m」，可以获取往期所有技术博文推送，更多资料回复下列关键字获取。</p>
</blockquote>
<p><img src="/images/weichat.png" alt=""></p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Linux/"><i class="fas fa-hashtag fa-fw"></i>Linux</a>
                
                    <a href="/tags/云计算/"><i class="fas fa-hashtag fa-fw"></i>云计算</a>
                
                    <a href="/tags/容器/"><i class="fas fa-hashtag fa-fw"></i>容器</a>
                
                    <a href="/tags/Docker/"><i class="fas fa-hashtag fa-fw"></i>Docker</a>
                
                    <a href="/tags/Namespace/"><i class="fas fa-hashtag fa-fw"></i>Namespace</a>
                
                    <a href="/tags/Cgroup/"><i class="fas fa-hashtag fa-fw"></i>Cgroup</a>
                
            </div>
        
    </section>
</article>

        </div>
      
    
      
        <div class="post-wrapper">
          <article class="post reveal ">
    
<section class="meta">
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/03/02/tech/cloud/container/容器生态系统/">
              
                  容器生态系统
              
          </a>
      </h2>
    

    
      <time class="metatag time">
        <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;2018-03-02
      </time>
    

    
      
    
    <div class="metatag cats">
        <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;<a class="categories" href="/categories/容器/">容器</a>
    </div>


    

    

    

  </div>
</section>

    <section class="article typo">
        <blockquote>
<p>文章首发于我的公众号「Linux云计算网络」，欢迎关注，第一时间掌握技术干货！</p>
</blockquote>
<p>说起生态，不禁让人想起贾跃亭的乐视，想当初我多次被它的生态布局给震撼到，一度相信它将要超越百度，坐拥互联网三大江山的宝座，但没过时日，各种劲爆的新闻就把它推到了风口浪尖上，现在想想也是让人唏嘘，但不管怎么说，愿它好吧，毕竟这种敢想敢做的精神还是值得敬佩的。</p>
<p>回到技术这个领域，不得不说，技术更新迭代的速度快得让人应接不暇，就容器技术这个领域来说，从 Docker 面世短短的 2-3 年时间里，就衍生出多种与之相关的技术框架，由此形成了一个小小的生态系统。</p>
<center><img src="/images/docker/docker_st.jpg" alt=""></center>

<p>一谈到容器，大家都会想到 Docker，本文也主要从 Docker 角度来讲容器生态系统。</p>
<h3 id="1-容器基础技术"><a href="#1-容器基础技术" class="headerlink" title="1 容器基础技术"></a>1 容器基础技术</h3><hr>
<p>Docker 的本质是利用 Linux 内核的 namespace 和 cgroups 机制，构建出一个隔离的进程（容器进程）。所以，容器的基础技术主要涉及到 Linux 内核的 namespace 和 cgroups 技术。</p>
<h3 id="2-容器核心技术"><a href="#2-容器核心技术" class="headerlink" title="2 容器核心技术"></a>2 容器核心技术</h3><hr>
<p>容器核心技术保证容器能够在主机上运行起来，包括容器规范、容器 runtime、容器管理工具、容器定义工具、Registry 和容器 OS。</p>
<center><img src="/images/docker/docker_core.jpg" alt=""></center>

<p>容器规范旨在将多种容器（如 OpenVZ，rkt，Docker 等）融合在一起，解决各种兼容问题，为此还专门成立了一个叫 OCI（Open Container Initiative）的组织来专门制定相关的容器规范。</p>
<p>容器 runtime 是容器真正运行的地方，一般需要依赖内核，也有运行在专门制定的容器 OS 上，关于容器 OS，下面会做介绍。lxc 、runc 和 rkt 是目前三种主流的 runtime。</p>
<blockquote>
<p>lxc 是 Linux 上老牌的容器 runtime。Docker 最初也是用 lxc 作为 runtime。<br>runc 是 Docker 自己开发的容器 runtime，符合 oci 规范，也是现在 Docker 的默认 runtime。<br>rkt 是 CoreOS 开发的容器 runtime，符合 oci 规范，因而能够运行 Docker 的容器。</p>
</blockquote>
<blockquote>
<p>容器管理工具是对外提供给用户的 CLI 接口，方便用户管理容器，对内与 runtime 交互。对应于不同的 runtime，分别有三种不同的管理工具：lxd、docker engine 和 rkt cli。</p>
</blockquote>
<p>容器定义工具允许用户定义容器的内容和属性，如容器需要什么镜像，装载什么应用等。常用有三种工具：docker images、Dockerfile 和 ACL（App Container Image）。</p>
<blockquote>
<p>docker images 是容器镜像，runtime 依据 docker images 创建容器。dockerfile 是包含若干命令的文本文件，可以通过这些命令创建出 docker images。ACI 与 docker images 类似，只不过它是由 CoreOS 开发的 rkt 容器的 images 格式。</p>
</blockquote>
<p>Registry 是存放容器镜像的仓库，包括 Docker Registry、Docker Hub 和 Quay.io，以及国内的 DaoCloud.io。企业可以用 Docker Registry 构建私有的 Registry。</p>
<p>容器 OS 不同于 runtime，是专门制定出来运行容器的操作系统，与常规 OS 相比，容器 OS 通常体积更小，启动更快。因为是为容器定制的 OS，通常它们运行容器的效率会更高。目前已经存在不少容器 OS，CoreOS、atomic 和 ubuntu core 是其中的杰出代表。</p>
<h3 id="3-容器平台技术"><a href="#3-容器平台技术" class="headerlink" title="3 容器平台技术"></a>3 容器平台技术</h3><hr>
<p>随着容器部署的增多，容器也逐步过渡到容器云，容器平台技术就是让容器作为集群在分布式的环境中运行，包括了容器编排引擎、容器管理平台和基于容器的 PaaS。</p>
<center><img src="/images/docker/docker_plat.jpg" alt=""></center>

<p>容器编排引擎就是管理、调度容器在集群中运行，以保障资源的合理利用。有名的三大编排引擎为 docker swarm、kubernetes 和 mesos。其中，kubernetes 这两年脱颖而出，成为其中的佼佼者。</p>
<p>容器管理平台是在编排引擎之上更为通用的一个平台，它抽象了编排引擎的底层实现细节，能够支持多种编排引擎，提供友好的接口给用户，极大方便了管理。Rancher 和 ContainerShip 是容器管理平台的典型代表。</p>
<p>基于容器的 PaaS 基于容器的 PaaS 为微服务应用开发人员和公司提供了开发、部署和管理应用的平台，使用户不必关心底层基础设施而专注于应用的开发。Deis、Flynn 和 Dokku 都是开源容器 PaaS 的代表。</p>
<h3 id="4-容器支持技术"><a href="#4-容器支持技术" class="headerlink" title="4 容器支持技术"></a>4 容器支持技术</h3><hr>
<p>容器的出现又重新让一些古老的技术焕发第二春，如监控、网络、数据管理、日志等技术，由于容器技术的不同，需要制定相应的符合容器规范的技术框架，由此有了容器支持技术，用于支持容器提供更丰富能力的基础设施。</p>
<center><img src="/images/docker/docker_zc.jpg" alt=""></center>

<p>其中包括容器网络、服务发现、监控、数据管理、日志管理和安全性。</p>
<p>容器网络主要用于解决容器与容器之间，容器与其他实体之间的连通性和隔离性。包括 Docker 原生的网络解决方案 docker network，以及第三方的网络解决方案，如  flannel、weave 和 calico。</p>
<p>服务发现保证容器使用过程中资源动态变化的感知性，如当负载增加时，集群会自动创建新的容器；负载减小，多余的容器会被销毁。容器也会根据 host 的资源使用情况在不同 host 中迁移，容器的 IP 和端口也会随之发生变化。在这种动态环境下，就需要有一种机制来感知这种变化，服务发现就是做这样的工作。etcd、consul 和 zookeeper 是服务发现的典型解决方案。</p>
<p>监控室保证容器健康运行，且让用户实时了解应用运行状态的工具，除了 Docker 原生的监控工具 docker ps/top/stats 之外，也有第三方的监控方案，如 sysdig、cAdvisor/Heapster 和 Weave Scope 。</p>
<p>数据管理保证容器在不同的 host 之间迁移时数据的动态迁移。有名的方案是 Flocker。</p>
<p>日志管理为问题排查和事件管理提供了重要依据。docker logs 是 Docker 原生的日志工具。而 logspout 对日志提供了路由功能，它可以收集不同容器的日志并转发给其他工具进行后处理。</p>
<p>容器安全性保证容器的安全，不被攻击，OpenSCAP 能够对容器镜像进行扫描，发现潜在的漏洞。</p>
<p>PS：本文借鉴了知名云计算博主 CloudMan 的博文：<br><a href="http://www.cnblogs.com/CloudMan6/p/6706546.html，感谢" target="_blank" rel="noopener">http://www.cnblogs.com/CloudMan6/p/6706546.html，感谢</a> CloudMan 呈现这么好的内容。</p>
<p>PS：文章未经我允许，不得转载，否则后果自负。</p>
<center>–END–</center>

<hr>
<blockquote>
<p>欢迎扫👇的二维码关注我的微信公众号，后台回复「m」，可以获取往期所有技术博文推送，更多资料回复下列关键字获取。</p>
</blockquote>
<p><img src="/images/weichat.png" alt=""></p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/云计算/"><i class="fas fa-hashtag fa-fw"></i>云计算</a>
                
                    <a href="/tags/容器/"><i class="fas fa-hashtag fa-fw"></i>容器</a>
                
                    <a href="/tags/Docker/"><i class="fas fa-hashtag fa-fw"></i>Docker</a>
                
            </div>
        
    </section>
</article>

        </div>
      
    
</section>



<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->






        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="plain">
  
<header class="material">
  <div><i class="fas fa-bullhorn fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;公告</div>
  
</header>

  <div class="content material">
    <p>你好，这里是<a href="https://ctimbai.github.io">猿大白</a>，我在这里分享技术和生活，专注于Linux/云计算/网络/CC++/Python/Go等技术栈，喜欢左手Coding，右手Writing，欢迎关注我的公众号「Linux云计算网络」，期待与你相遇~</p>

  </div>
</section>

      
    
  
    
      
      
        <section class="author">
  <div class="content material">
    
      <div class="avatar">
        <img class="avatar" src="/images/cloud.png">
      </div>
    
    
      <div class="text">
        
        
          <p>公众号：Linux云计算网络</p>

        
        
      </div>
    
    
  </div>
</section>

      
    
  
    
      
      
        
  <section class="category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/DPDK/" href="/categories/DPDK/"><div class="name">DPDK</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Docker/" href="/categories/Docker/"><div class="name">Docker</div><div class="badge">(8)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Kubernetes/" href="/categories/Kubernetes/"><div class="name">Kubernetes</div><div class="badge">(14)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Linux/" href="/categories/Linux/"><div class="name">Linux</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/OVS/" href="/categories/OVS/"><div class="name">OVS</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Python/" href="/categories/Python/"><div class="name">Python</div><div class="badge">(8)</div></a></li>
        
          <li><a class="flat-box" title="/categories/TCP-IP/" href="/categories/TCP-IP/"><div class="name">TCP/IP</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/云计算/" href="/categories/云计算/"><div class="name">云计算</div><div class="badge">(7)</div></a></li>
        
          <li><a class="flat-box" title="/categories/容器/" href="/categories/容器/"><div class="name">容器</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/工具/" href="/categories/工具/"><div class="name">工具</div><div class="badge">(8)</div></a></li>
        
          <li><a class="flat-box" title="/categories/性能分析/" href="/categories/性能分析/"><div class="name">性能分析</div><div class="badge">(5)</div></a></li>
        
          <li><a class="flat-box" title="/categories/算法与数据结构/" href="/categories/算法与数据结构/"><div class="name">算法与数据结构</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/网络/" href="/categories/网络/"><div class="name">网络</div><div class="badge">(11)</div></a></li>
        
          <li><a class="flat-box" title="/categories/网络工具/" href="/categories/网络工具/"><div class="name">网络工具</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/虚拟化/" href="/categories/虚拟化/"><div class="name">虚拟化</div><div class="badge">(9)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="material">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content material">
      <a href="/tags/Bridge/" style="font-size: 17.08px; color: #848484">Bridge</a> <a href="/tags/CNM/" style="font-size: 14px; color: #999">CNM</a> <a href="/tags/CPU/" style="font-size: 16.31px; color: #898989">CPU</a> <a href="/tags/Cgroup/" style="font-size: 14.77px; color: #949494">Cgroup</a> <a href="/tags/DPDK/" style="font-size: 15.54px; color: #8f8f8f">DPDK</a> <a href="/tags/Django/" style="font-size: 14px; color: #999">Django</a> <a href="/tags/Docker/" style="font-size: 20.15px; color: #6f6f6f">Docker</a> <a href="/tags/I-O/" style="font-size: 14px; color: #999">I/O</a> <a href="/tags/ICMP/" style="font-size: 14px; color: #999">ICMP</a> <a href="/tags/KVM/" style="font-size: 17.08px; color: #848484">KVM</a> <a href="/tags/Kata/" style="font-size: 14px; color: #999">Kata</a> <a href="/tags/Kubernetes/" style="font-size: 21.69px; color: #656565">Kubernetes</a> <a href="/tags/LaTeX/" style="font-size: 14.77px; color: #949494">LaTeX</a> <a href="/tags/Linux/" style="font-size: 23.23px; color: #5a5a5a">Linux</a> <a href="/tags/NAT/" style="font-size: 14px; color: #999">NAT</a> <a href="/tags/NFV/" style="font-size: 14px; color: #999">NFV</a> <a href="/tags/NUMA/" style="font-size: 15.54px; color: #8f8f8f">NUMA</a> <a href="/tags/Namespace/" style="font-size: 15.54px; color: #8f8f8f">Namespace</a> <a href="/tags/Numpy/" style="font-size: 14px; color: #999">Numpy</a> <a href="/tags/OVS/" style="font-size: 16.31px; color: #898989">OVS</a> <a href="/tags/OpenFlow/" style="font-size: 14.77px; color: #949494">OpenFlow</a> <a href="/tags/OpenStack/" style="font-size: 14px; color: #999">OpenStack</a> <a href="/tags/Pouch/" style="font-size: 14px; color: #999">Pouch</a> <a href="/tags/Python/" style="font-size: 18.62px; color: #7a7a7a">Python</a> <a href="/tags/Qemu/" style="font-size: 16.31px; color: #898989">Qemu</a> <a href="/tags/SDN/" style="font-size: 14px; color: #999">SDN</a> <a href="/tags/SPDK/" style="font-size: 14px; color: #999">SPDK</a> <a href="/tags/Sublime-Text/" style="font-size: 14px; color: #999">Sublime Text</a> <a href="/tags/UIO/" style="font-size: 14px; color: #999">UIO</a> <a href="/tags/VLAN/" style="font-size: 14.77px; color: #949494">VLAN</a> <a href="/tags/VPP/" style="font-size: 14px; color: #999">VPP</a> <a href="/tags/cacico/" style="font-size: 14px; color: #999">cacico</a> <a href="/tags/flannel/" style="font-size: 14px; color: #999">flannel</a> <a href="/tags/fstack/" style="font-size: 14px; color: #999">fstack</a> <a href="/tags/git/" style="font-size: 15.54px; color: #8f8f8f">git</a> <a href="/tags/github/" style="font-size: 14.77px; color: #949494">github</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/ipip/" style="font-size: 14px; color: #999">ipip</a> <a href="/tags/libnetwork/" style="font-size: 14px; color: #999">libnetwork</a> <a href="/tags/mTCP/" style="font-size: 14.77px; color: #949494">mTCP</a> <a href="/tags/macvlan/" style="font-size: 15.54px; color: #8f8f8f">macvlan</a> <a href="/tags/matplotlib/" style="font-size: 14px; color: #999">matplotlib</a> <a href="/tags/overlay/" style="font-size: 14px; color: #999">overlay</a> <a href="/tags/tap/" style="font-size: 17.08px; color: #848484">tap</a> <a href="/tags/tcpdump/" style="font-size: 14px; color: #999">tcpdump</a> <a href="/tags/tun/" style="font-size: 17.08px; color: #848484">tun</a> <a href="/tags/tunnel/" style="font-size: 14px; color: #999">tunnel</a> <a href="/tags/veth-pair/" style="font-size: 15.54px; color: #8f8f8f">veth-pair</a> <a href="/tags/vhost/" style="font-size: 14.77px; color: #949494">vhost</a> <a href="/tags/vhost-user/" style="font-size: 14px; color: #999">vhost_user</a> <a href="/tags/virtio/" style="font-size: 14.77px; color: #949494">virtio</a> <a href="/tags/vrouter/" style="font-size: 14px; color: #999">vrouter</a> <a href="/tags/weave/" style="font-size: 14px; color: #999">weave</a> <a href="/tags/乱码/" style="font-size: 14px; color: #999">乱码</a> <a href="/tags/云计算/" style="font-size: 24px; color: #555">云计算</a> <a href="/tags/内存/" style="font-size: 14.77px; color: #949494">内存</a> <a href="/tags/大页内存/" style="font-size: 14px; color: #999">大页内存</a> <a href="/tags/容器/" style="font-size: 19.38px; color: #747474">容器</a> <a href="/tags/容器网络/" style="font-size: 17.08px; color: #848484">容器网络</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/性能分析/" style="font-size: 17.85px; color: #7f7f7f">性能分析</a> <a href="/tags/技能图谱/" style="font-size: 14.77px; color: #949494">技能图谱</a> <a href="/tags/数据结构/" style="font-size: 14px; color: #999">数据结构</a> <a href="/tags/混合云/" style="font-size: 14px; color: #999">混合云</a> <a href="/tags/简历/" style="font-size: 14px; color: #999">简历</a> <a href="/tags/算法/" style="font-size: 14px; color: #999">算法</a> <a href="/tags/网络/" style="font-size: 22.46px; color: #5f5f5f">网络</a> <a href="/tags/虚拟化/" style="font-size: 20.92px; color: #6a6a6a">虚拟化</a> <a href="/tags/集群/" style="font-size: 14px; color: #999">集群</a> <a href="/tags/零拷贝/" style="font-size: 14px; color: #999">零拷贝</a> <a href="/tags/雾计算/" style="font-size: 14px; color: #999">雾计算</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="material">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;友链</div>
  
</header>

  <div class="content material">
    <ul class="entry">
      
        <li><a class="flat-box" title="about/" href="/about/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;关于我 / 留言板
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  
    
      
      
        

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  






    <script>setLoadingBarProgress(100);</script>
</body>
</html>
